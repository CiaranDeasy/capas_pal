(********* Author: Ciaran Deasy    **********)
(********* cfd27@cam.ac.uk ******************)
(********* Part II Project ******************)
(********* University of Cambridge **********)

(*******************************************************************************
This source file contains datatypes used by the Prolog interpreter/compiler, and
the equality tests for those datatypes.
*******************************************************************************)

(* The token datatype represents tokens generated by the Prolog lexer. *)
datatype token = ATOM of string
               | VARIABLE of string
               | INT of int
               | FLOAT of real
               | LEFTPAREN
               | RIGHTPAREN
               | COMMA
               | DOT
               | LEFTSQ
               | RIGHTSQ
               | PIPE
               | COLONMINUS
               | IS
               | PLUS
               | MINUS
               | MULT
               | DIV
               | MOD
               | EOF;

(* The following datatypes represent a parsed Prolog program. *)
datatype functor_t = Functor of string;
datatype term_t = Term of functor_t * term_t list
                | Variable of string * int
                | IntTerm of int
                | FloatTerm of real;
datatype clause_t = Clause of term_t * term_t list;
datatype program_t = Program of clause_t list;
datatype query_t = Query of term_t list;
datatype binding_t = Binding of term_t * term_t;
datatype unifier_t = Unifier of binding_t list;
          

(*******************************************************************************
The following are the equality tests for the above datatypes.
*******************************************************************************)

(* Equality test for tokens. *)
fun eqToken( ATOM(a1), ATOM(a2) ) = ( a1 = a2 )
  | eqToken( VARIABLE(v1), VARIABLE(v2) ) = ( v1 = v2 )
  | eqToken( INT(i1), INT(i2) ) = ( i1 = i2 )
  | eqToken( FLOAT(f1), FLOAT(f2) ) = ( Real.==( f1, f2 ) )
  | eqToken( LEFTPAREN, LEFTPAREN ) = true
  | eqToken( RIGHTPAREN, RIGHTPAREN ) = true
  | eqToken( COMMA, COMMA ) = true
  | eqToken( DOT, DOT ) = true
  | eqToken( LEFTSQ, LEFTSQ ) = true
  | eqToken( RIGHTSQ, RIGHTSQ ) = true
  | eqToken( PIPE, PIPE ) = true
  | eqToken( COLONMINUS, COLONMINUS ) = true
  | eqToken( IS, IS ) = true
  | eqToken( PLUS, PLUS ) = true
  | eqToken( MINUS, MINUS ) = true
  | eqToken( MULT, MULT ) = true
  | eqToken( DIV, DIV ) = true
  | eqToken( MOD, MOD ) = true
  | eqToken( EOF, EOF ) = true
  | eqToken( _, _ ) = false;

(* Equality test for Terms *)
fun eqTerm( Term( f1, args1 ), Term( f2, args2 ) ) = 
        ( f1 = f2 ) andalso ( eqOrderedList eqTerm ( args1, args2 ) )
  | eqTerm( Variable( v1, s1 ), Variable( v2, s2 ) ) =
        ( v1 = v2 ) andalso ( s1 = s2 )
  | eqTerm( IntTerm( i1 ), IntTerm( i2 ) ) = ( i1 = i2 )
  | eqTerm( FloatTerm( f1 ), FloatTerm( f2 ) ) = Real.==( f1, f2 )
  | eqTerm( term1, term2 ) = false;

(* Equality test for Bindings *)
fun eqBinding( Binding( term1A, term1B ), Binding( term2A, term2B ) ) = 
        ( eqTerm( term1A, term2A ) andalso eqTerm( term1B, term2B ) )
          orelse ( eqTerm( term1A, term2B ) andalso eqTerm( term1B, term2A ) );

(* Equality test for Unifiers *)
fun eqUnifier ( Unifier(xs), Unifier(ys) ) = eqUnorderedList eqBinding ( xs, ys );

(* Equality test for Clauses *)
fun eqClause( Clause(head1, body1), Clause(head2, body2) ) = 
        eqTerm( head1, head2 ) andalso eqOrderedList eqTerm ( body1, body2 );
